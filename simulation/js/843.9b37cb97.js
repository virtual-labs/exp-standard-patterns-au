"use strict";(self["webpackChunkexp_8"]=self["webpackChunkexp_8"]||[]).push([[843],{9843:function(a,e,t){t.r(e),t.d(e,{default:function(){return i}});var s=t(3396);const r=(0,s.uE)('<header style="padding:20px;" data-v-32bf9e7a><h5 data-v-32bf9e7a>HELP</h5><h1 data-v-32bf9e7a>Factory Pattern</h1></header><div id="snackbar" data-v-32bf9e7a>Some text some message..</div><main data-v-32bf9e7a><div class="flex-row" data-v-32bf9e7a><div style="width:30%;" data-v-32bf9e7a><h2 data-v-32bf9e7a>Theory</h2><div class="outbox" data-v-32bf9e7a><span id="comment" data-v-32bf9e7a>//The class Shape, Circle are designed as follows</span><p data-v-32bf9e7a>public interface shape {</p><p data-v-32bf9e7a>public void draw(); }</p><p data-v-32bf9e7a>public class Circle extends Shape {</p><p data-v-32bf9e7a>public void draw() {</p><p data-v-32bf9e7a>System.out.println(&quot;inside Circle draw() method&quot;); } }</p><span id="comment" data-v-32bf9e7a>//The class ShapeFactory and ShapeDemo are designed as follows: </span><p data-v-32bf9e7a>public class ShapeFactory {</p><p data-v-32bf9e7a>public Shape getShape(String shapeType){ </p><p data-v-32bf9e7a>if (shapeType == null) {</p><p data-v-32bf9e7a>return null; }</p><p data-v-32bf9e7a>if (shapeType.equalsIgnoreCase(&quot;Circle&quot;)){</p><p data-v-32bf9e7a>return new Circle(); } } }</p><br data-v-32bf9e7a><p data-v-32bf9e7a>public class ShapeDemo{</p><p data-v-32bf9e7a>public static void main(String[] args){</p><p data-v-32bf9e7a>ShapeFactory shapeFactory = new ShapeFactory();</p><p data-v-32bf9e7a>Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);</p><p data-v-32bf9e7a>shape1.draw(); } }</p><br data-v-32bf9e7a></div></div><div class="content" data-v-32bf9e7a><p data-v-32bf9e7a> Factory is a creational design pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. It promotes the loose-coupling by eliminating the need to bind application-specific classes. </p><br data-v-32bf9e7a><p data-v-32bf9e7a>Need for Factory pattern: </p><br data-v-32bf9e7a><p data-v-32bf9e7a>1. When a class doesn&#39;t know what sub-classes will be required</p><br data-v-32bf9e7a><p data-v-32bf9e7a>2. When a class wants that its sub-classes specify the objects to be created.</p><br data-v-32bf9e7a><p data-v-32bf9e7a>3. When the parent classes choose the creation of objects to its sub-classes.</p></div></div></main>',3);function p(a,e,t,s,p,c){return r}var c={data(){return{}},methods:{incorrect(a){var e=document.getElementById("snackbar");e.innerHTML=a,e.style.backgroundColor="red",e.className="show",setTimeout((function(){e.className=e.className.replace("show","")}),3e3)},correct1(){var a=document.getElementById("snackbar");a.innerHTML="Correct",a.style.backgroundColor="green",a.className="show",setTimeout((function(){a.className=a.className.replace("show","")}),3e3)},validate_one(){"float"==this.one.trim()&&"key[]"==this.two.trim()&&"new"==this.three.trim()&&"float[5]"==this.four.trim()?(this.correct1(),alert("Correct ")):(this.incorrect("Try again"),alert("Incorrect, please try again"))}}},o=t(89);const d=(0,o.Z)(c,[["render",p],["__scopeId","data-v-32bf9e7a"]]);var i=d}}]);
//# sourceMappingURL=843.9b37cb97.js.map